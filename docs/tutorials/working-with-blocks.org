#+TITLE: Working with blocks
#+AUTHOR: Joshua Munn
#+EMAIL: public@elysee-munn.family
#+OPTIONS: toc:nil num:nil
#+PROPERTY: header-args:python :python "uv run python" :session working-with-blocks-django :exports code
#+PROPERTY: header-args:bash :session shell

* Init :noexport:

#+begin_src python :exports none :var root = (expand-file-name (project-root (project-current)))
  import os
  import django

  os.chdir(root)
  os.environ.setdefault("DJANGO_SETTINGS_MODULE", "tutorial.settings.dev")
  django.setup()
#+end_src

#+RESULTS:
: None

* Prerequisites from getting-started tutorial :noexport:

The following code blocks are automatically extracted from the getting-started tutorial, as if we just tangle this file without them it overwrites the model definitions from that file.

#+begin_src elisp :exports none :results value drawer
  (defun extract-all-tangle-blocks (file)
    "Extract all src blocks that have :tangle parameter from FILE."
    (with-temp-buffer
      (insert-file-contents file)
      (goto-char (point-min))
      (let ((blocks '()))
        (while (re-search-forward "^#\\+begin_src.*:tangle" nil t)
          (beginning-of-line)
          (let ((block-start (point)))
            (when (re-search-forward "^#\\+end_src" nil t)
              (push (buffer-substring-no-properties block-start (point)) blocks))))
        (reverse blocks))))

  (let* ((getting-started-path (expand-file-name "docs/tutorials/getting-started.org" (project-root (project-current))))
         (tangle-blocks (extract-all-tangle-blocks getting-started-path)))
    (if tangle-blocks
        (string-join tangle-blocks "\n\n")
      ""))
#+end_src

#+RESULTS:
:results:
#+begin_src python :eval no :tangle "../../home/models.py" :comments link
  from wagtail.models import Page


  class HomePage(Page):
      pass
#+end_src

#+begin_src python :eval no :tangle "../../home/models.py" :comments link
  from django.db import models
  from wagtail.documents import get_document_model
  from wagtail.images import get_image_model


  class BlogPage(Page):
      hero_image = models.ForeignKey(
          get_image_model(),
          on_delete=models.PROTECT,
          related_name="+",
      )
      splash_text = models.TextField(blank=True)
      related_page = models.ForeignKey(
          Page,
          null=True,
          blank=True,
          on_delete=models.SET_NULL,
          related_name="related_pages",
      )
      policy = models.ForeignKey(
          get_document_model(),
          null=True,
          blank=True,
          on_delete=models.SET_NULL,
          related_name="+",
      )
#+end_src

#+begin_src python :eval no :tangle "../../home/factories.py" :comments link
  import factory
  from wagtail_factories import PageFactory

  from home.models import HomePage


  class HomePageFactory(PageFactory):
      class Meta:
          model = HomePage
#+end_src

#+begin_src python :eval no :tangle "../../home/factories.py" :comments link
  from wagtail_factories import DocumentFactory, ImageFactory

  from home.models import BlogPage


  class BlogPageFactory(PageFactory):
      hero_image = factory.SubFactory(ImageFactory)
      splash_text = factory.Faker("paragraph")
      related_page = factory.SubFactory(PageFactory)
      policy = factory.SubFactory(DocumentFactory)

      class Meta:
          model = BlogPage
#+end_src
:end:

* Goals

Wagtail's killer feature is the [[https://docs.wagtail.org/en/stable/topics/streamfield.html][stream field system for flexible content]]. In this tutorial we will learn how to create and use factory classes that enable us to generate content for stream field blocks, just like we would with factories for Django models.

We assume a working knowledge of Wagtail and a passing knowledge of [[https://factoryboy.readthedocs.io/en/stable/][factory boy]]. This tutorial also assumes you've read [[file:getting-started.rst][the getting started tutorial]], and have a Wagtail project with the structures, models, and factories as defined there.

* Defining stream field blocks

Before creating any factories, we will create a Django model with a stream field and a set of blocks that define its content model. Create the following model for a fictional animal charity in ~home/models.py~.

#+begin_src python :eval no :tangle "../../home/models.py" :comments link
  from wagtail.fields import StreamField
  from wagtail.models import Page

  from home.blocks import PetsBlock


  class PetPage(Page):
      pets = StreamField(PetsBlock())
#+end_src

We need to define ~PetsBlock~, so create it in ~home/blocks.py~.

#+begin_src python :eval no :tangle "../../home/blocks.py" :comments link
  from wagtail import blocks
  from wagtail.images.blocks import ImageBlock


  def get_colour_choices():
      return [
          ("calico", "Calico"),
          ("tabby", "Tabby"),
          ("orange", "Orange"),
      ]


  class ScheduledFeedingBlock(blocks.StructBlock):
      time = blocks.TimeBlock()
      portions = blocks.IntegerBlock()
      food = blocks.CharBlock()


  class PetStoryBlock(blocks.StreamBlock):
      text = blocks.TextBlock()
      link = blocks.URLBlock()
      image = ImageBlock()


  class PetBlock(blocks.StructBlock):
      story = PetStoryBlock()
      name = blocks.CharBlock()
      date_of_birth = blocks.DateBlock()
      feeding_schedule = blocks.ListBlock(ScheduledFeedingBlock())
      colour = blocks.ChoiceBlock(choices=get_colour_choices)
      picture = ImageBlock()


  class CatBlock(PetBlock):
      pass


  class DogBlock(PetBlock):
      pass


  class PetsBlock(blocks.StreamBlock):
      cat = CatBlock()
      dog = DogBlock()
#+end_src

The block definition contains a variety of structures:

- stream blocks (~PetsBlock~, ~PetBlock.story~);
- a list block;
- struct blocks;
- image blocks;
- choice blocks; and
- various atomic block types.

Create and run the migrations.

#+begin_src bash :results output :exports code
  uv run python manage.py makemigrations --noinput --no-color
  uv run python manage.py migrate --noinput --no-color
#+end_src

#+RESULTS:
: Migrations for 'home':
:   home/migrations/0005_petpage.py
:     + Create model PetPage
: Operations to perform:
:   Apply all migrations: admin, auth, contenttypes, home, sessions, taggit, wagtailadmin, wagtailcore, wagtaildocs, wagtailembeds, wagtailforms, wagtailimages, wagtailredirects, wagtailsearch, wagtailusers
: Running migrations:
:   Applying home.0005_petpage... OK

* Block factories

With our model and block definitions in place, it's time to create our block factories. wagtail-factories provides us with the following tools:

- ~StreamBlockFactory~;
- ~StreamFieldFactory~;
- ~ListBlockFactory~;
- ~StructBlockFactory~;
- ~PageChooserBlockFactory~;
- ~ImageChooserBlockFactory~;
- ~DocumentChooserBlockFactory~;
- ~ImageBlockFactory~; and
- some factories atomic block types, although as we'll see they aren't as essential as the factories for compound block types.

We'll start with the bottom of the tree, a factory for ~ScheduledFeedingBlock~.

** Factories for struct blocks

Add the following code to ~home/factories.py~.

#+begin_src python :eval no :tangle "../../home/factories.py" :comments link
  import factory
  from wagtail_factories import StructBlockFactory

  from home.blocks import ScheduledFeedingBlock


  class ScheduledFeedingBlockFactory(StructBlockFactory):
      time = factory.Faker("time_object")
      portions = factory.Faker("random_int", min=1, max=100)
      food = factory.Faker(
          "random_element", elements=["kibble", "tuna", "salmon", "carrots"]
      )

      class Meta:
          model = ScheduledFeedingBlock
#+end_src

We have:

- created a ~StructBlockFactory~ subclass for our ~StructBlock~ subclass;
- added a field for each field on the block definition; and
- added an inner ~Meta~ class with a ~model~ attribute which is the corresponding block class.

The ~Meta.model~ declaration is essential: wagtail-factories needs this to create values of the correct type. It should be the relevant block class.

In this example, we're using the API exposed by ~factory.Faker~. This helps us to generate reasonable-looking defaults for fields we don't specify explicit values for when creating block instances.

#+begin_src python :exports both :results value pp
  import home.factories as f


  f.ScheduledFeedingBlockFactory()
#+end_src

#+RESULTS:
: StructValue([('time', datetime.time(20, 38, 43, 521698)),
:              ('portions', 71),
:              ('food', 'tuna')])

We can also specify values for some or all of the fields.

#+begin_src python :exports both :results value pp
  f.ScheduledFeedingBlockFactory(
      portions=3,
      food="kibble",
  )
#+end_src

#+RESULTS:
: StructValue([('time', datetime.time(21, 8, 30, 44821)),
:              ('portions', 3),
:              ('food', 'kibble')])

** Stream block factories

Looking back at the definition of ~PetBlock~, we can see that it contains a stream block definition.

#+begin_src python :eval never :exports code
  class PetStoryBlock(blocks.StreamBlock):
      text = blocks.TextBlock()
      link = blocks.URLBlock()
      image = ImageBlock()


  class PetBlock(blocks.StructBlock):
      ...
      story = PetStoryBlock()
      ...
#+end_src

Create a factory for ~PetStoryBlock~ in ~home/factories.py~. We'll use faker instances for the atomic fields, and a ~SubFactory~ for the nested ~ImageBlock~.

#+begin_src python :eval no :tangle "../../home/factories.py" :comments link
  import factory
  from wagtail_factories import ImageBlockFactory, StreamBlockFactory

  from home.blocks import PetStoryBlock


  class PetStoryBlockFactory(StreamBlockFactory):
      image = factory.SubFactory(ImageBlockFactory)
      text = factory.Faker("sentence")
      link = factory.Faker("uri")

      class Meta:
          model = PetStoryBlock
#+end_src

Again, note the inner ~Meta~ class with ~model~ definition - this is required.

*** Using a stream block factory

Let's try using our new stream block value to generate a value.

#+begin_src python :exports both :results value pp
  import home.factories as f


  f.PetStoryBlockFactory()
#+end_src

#+RESULTS:
: <StreamValue []>

With no parameters, an empty ~StreamValue~ is generated.

Given that a ~StreamValue~ is an ordered sequence type, how do we specify values for its elements? wagtail-factories supports a syntax for declaring parameters that includes indices for list block and stream block factories. That syntax comes in two flavours:

1. a "default value" flavour; and
2. a "specified value" flavour.

The default value flavour looks like this:

#+begin_quote
<index>=<block name string>
#+end_quote

So, to create an instance of ~PetStoryBlock~ where the first element is a text block, we would do the following:

#+begin_src python :exports both :results value pp
  f.PetStoryBlockFactory(**{"0": "text"})
#+end_src

#+RESULTS:
: <StreamValue [<block text: 'Candidate current floor forward.'>]>

Ideally, we wouldn't need the dict-unpacking to insert the keyword-argument parameters, but Python identifiers cannot begin with a numeric character. This will not be an issue when used in the context of a page (or other containing model), as you'll see in later examples.

The syntax for the "specified value" flavour looks like this:

#+begin_quote
<index>__<block name>=<value>
#+end_quote

For example:

#+begin_src python :exports both :results value pp
  f.PetStoryBlockFactory(**{"0__text": "hello"})
#+end_src

#+RESULTS:
: <StreamValue [<block text: 'hello'>]>

We can combine these two syntaxes arbitrarily, and create streams with multiple elements:

#+begin_src python :exports both :results value pp
  f.PetStoryBlockFactory(**{"0__text": "hello", "1": "link", "2": "text"})
#+end_src

#+RESULTS:
: <StreamValue [<block text: 'hello'>, <block link: 'https://www.harrington-peterson.com/category/categoriesregister.asp'>, <block text: 'Gas rather business design price fire score.'>]>

However, indices /must/ start at zero, and /must/ be sequential.

#+begin_src python :exports code :results value pp
  f.PetStoryBlockFactory(**{"0": "link", "7": "link"})
#+end_src

#+begin_quote
wagtail_factories.builder.InvalidDeclaration:
  Parameters for <PetStoryBlockFactory for <class 'home.blocks.PetStoryBlock'>>
  missing required index 1
#+end_quote

We can also use double-underscores to traverse the block definition tree, and specify values for nested compound blocks, such as the image block option in ~PetStoryBlock~.

#+begin_src python :exports code :results value pp
  with_image = f.PetStoryBlockFactory(**{"0__image__decorative": True})
  with_image[0].value.decorative
#+end_src

#+RESULTS:
: True

To specify multiple values for a particular nested block, we can add declarations with the same ~<index>__<block_name>~ prefix.

#+begin_src python :exports code :results value pp
  with_image = f.PetStoryBlockFactory(
      ,**{
          "0__image__decorative": False,
          "0__image__alt_text": "An orange cat lying in the sun",
      }
  )

  with_image[0].value.decorative, with_image[0].value.contextual_alt_text
#+end_src

#+RESULTS:
: (False, 'An orange cat lying in the sun')

** Tying it all together

#+begin_src python :eval no :tangle "../../home/factories.py" :comments link
  from wagtail_factories import (
      CharBlockFactory,
      ListBlockFactory,
      PageFactory,
      StreamFieldFactory,
  )
  from home.blocks import PetBlock, get_colour_choices, CatBlock, DogBlock, PetsBlock
  from home.models import PetPage


  class PetBlockFactory(StructBlockFactory):
      story = factory.SubFactory(PetStoryBlockFactory)
      name = factory.Faker("name")
      date_of_birth = factory.Faker("date_object")
      feeding_schedule = ListBlockFactory(ScheduledFeedingBlockFactory)
      colour = factory.Faker(
          "random_element", elements=[x[0] for x in get_colour_choices()]
      )
      picture = factory.SubFactory(ImageBlockFactory)

      class Meta:
          model = PetBlock


  class CatBlockFactory(PetBlockFactory):
      class Meta:
          model = CatBlock


  class DogBlockFactory(PetBlockFactory):
      class Meta:
          model = DogBlock


  class PetsBlockFactory(StreamBlockFactory):
      cat = factory.SubFactory(CatBlockFactory)
      dog = factory.SubFactory(DogBlockFactory)

      class Meta:
          model = PetsBlock


  class PetPageFactory(PageFactory):
      pets = StreamFieldFactory(PetsBlockFactory)

      class Meta:
          model = PetPage
#+end_src
